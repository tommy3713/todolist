import express from 'express'
import { Request, Response, Express } from 'express'
import { Server } from 'http'
import * as t from 'io-ts'
import { pipe } from 'fp-ts/function'
import * as E from 'fp-ts/Either'
import * as TE from 'fp-ts/TaskEither'
import * as A from 'fp-ts/Array'
import { Predicate } from 'fp-ts/Predicate'
import { allPass } from 'fp-ts-std/Predicate'
import * as B from 'fp-ts/boolean'
import { isNonEmptyString } from 'newtype-ts/lib/NonEmptyString'
import swaggerUi from 'swagger-ui-express'
import cors from 'cors'
import bodyParser from 'body-parser'
import YAML from 'yamljs'
import { Todo, todoRepoOf } from '@todoRepo'
import { Errors } from 'io-ts'

type ExpressServer = {
  start: (port: number) => TE.TaskEither<Error, void>
  close: () => TE.TaskEither<Error, void>
}

type RequestParamError = { _tag: 'RequestParamError'; msg: string }
const requestParamErrorOf: (msg: string) => RequestParamError = (msg) => ({ _tag: 'RequestParamError', msg })
const validationErrors2ReqParamError: (e: Errors) => RequestParamError = (e) => ({
  _tag: 'RequestParamError',
  msg: `${pipe(
    e,
    A.map(JSON.stringify),
    A.foldLeft(
      () => 'Request param decoding failure',
      (x, y) => `${x}\n${y}`
    )
  )}`,
})

const isIdNotEmpty: Predicate<Todo> = (v: Todo) => isNonEmptyString(v.id)
const isStatusNotEmpty: Predicate<Todo> = (v: Todo) => isNonEmptyString(v.status)
const isTaskNameNotEmpty: Predicate<Todo> = (v: Todo) => isNonEmptyString(v.taskName)

const serverOf: () => ExpressServer = () => {
  const app: Express = express()
  const swaggerJSDocs = YAML.load('api/api-doc.yaml')

  app.use(bodyParser.json())
  app.use(cors())
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerJSDocs))

  // const todos: Todo[] = []
  const repo = todoRepoOf()
  // RESTful todo list api
  // GET
  // TODO - this change CAN break the client behaviour
  app.get('/api/todos', async (req: Request, res: Response): Promise<void> => {
    await pipe(
      repo.all(),
      TE.match(
        (_) => res.sendStatus(404),
        (t) => res.status(200).json(t)
      )
    )()
  })

  // POST
  app.post('/api/todos', async (req: Request, res: Response): Promise<void> => {
    await pipe(
      Todo.decode(req.body),
      E.match(
        (errors) => Promise.resolve(res.status(400).json({ errors })),
        (todo) =>
          B.fold(
            () => Promise.resolve(res.status(400).send('Properties cannot be null')),
            () =>
              pipe(repo.insert(todo), (x) =>
                pipe(
                  x,
                  TE.match(
                    (e) => res.status(500).send(e.msg),
                    (todo) => res.status(201).send(todo)
                  )
                )
              )()
          )(allPass([isIdNotEmpty, isStatusNotEmpty, isTaskNameNotEmpty])(todo))
      )
    )
  })

  // PUT
  app.put('/api/todos/:id', async (req: Request, res: Response): Promise<void> => {
    const id = req.params.id
    const updatedTodo = req.body
    // TODO - provided the id is not generated by the server, not reasonable to find a Todo with this `id` when the whole updated Todo is provided
    const updateTodo = (validId: string) => (validTodo: Todo) => repo.update(validTodo)

    await pipe(
      TE.Do,
      TE.apS('id', pipe(TE.fromEither(t.string.decode(id)), TE.mapLeft(validationErrors2ReqParamError))),
      TE.apS('todo', pipe(TE.fromEither(Todo.decode(updatedTodo)), TE.mapLeft(validationErrors2ReqParamError))),
      TE.chain(({ id, todo }) =>
        pipe(
          updateTodo(id)(todo),
          TE.mapLeft((e) => requestParamErrorOf(e.msg))
        )
      ),
      TE.match(
        (e) => res.status(400).send(e.msg),
        (todo) => res.status(200).send(todo)
      )
    )()
  })

  // DELETE
  app.delete('/api/todos/:id', async (req: Request, res: Response): Promise<void> => {
    const decoded = t.type({ id: t.string }).decode(req.params)

    await pipe(
      decoded,
      E.match(
        (errors) => Promise.resolve(res.status(400).json({ errors })),
        ({ id }) =>
          pipe(
            repo.delete(id),
            TE.match(
              (e) => res.status(500).send(e.msg),
              (t) => res.status(200).json(t)
            )
          )()
      )
    )
  })

  let server: Server

  return {
    start: (port) =>
      pipe(
        E.tryCatch(
          () => {
            server = app.listen(port, (): void => {
              console.log(`Server Running here  https://localhost:${port}`)
            })
          },
          (e) => Error(`Express failed to start at port ${port}: ${JSON.stringify(e)}`)
        ),
        TE.fromEither
      ),
    close: () =>
      pipe(
        TE.fromNullable(Error(`No express server initiated`))(server),
        TE.map((_) => {
          _.close()
        })
      ),
  }
}

export const server = serverOf()
